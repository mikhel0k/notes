
Чтобы зарегистрировать пользователя нужна создать таблицу в базе данных в которую будем сохранять пользователя, для примера возьму следующую таблицу
```
from pydantic import EmailStr  
from sqlalchemy import String, Boolean  
from sqlalchemy.orm import Mapped, mapped_column  
  
from .BaseModel import BaseModel  
  
  
class User(BaseModel):  
    __tablename__ = 'users'  
  
    username: Mapped[str] = mapped_column(String, nullable=False)  
    first_name: Mapped[str | None] = mapped_column(String, nullable=True)  
    second_name: Mapped[str | None] = mapped_column(String, nullable=True)  
    email: Mapped[EmailStr] = mapped_column(String, nullable=False)  
    password: Mapped[str] = mapped_column(String, nullable=False)  
  
    is_reader: Mapped[bool] = mapped_column(Boolean, nullable=False, default=True)  
    is_author: Mapped[bool] = mapped_column(Boolean, nullable=False, default=False)  
    is_admin: Mapped[bool] = mapped_column(Boolean, nullable=False, default=False)
```
Отличие от обычных таблиц [[Создание таблиц SQLAlchemy]] в том что нужно прописывать поля для прав доступа пользователю, также тут часть полей сделаны не обязательными чтобы при регистрации не делать их заполнение обязательным.

Также нужно сделать pydantic схемы [[Как создать pydantic схему]]
```
from datetime import datetime  
  
from pydantic import BaseModel, EmailStr, ConfigDict  
  
  
class CreateUser(BaseModel):  
    username: str  
    email: EmailStr  
    password: str  
  
  
class UpdateUser(BaseModel):  
    first_name: str | None  
    second_name: str | None  
    email: EmailStr | None  
  
  
class UserResponse(BaseModel):  
    model_config = ConfigDict(from_attributes=True)  
  
    username: str  
    first_name: str | None  
    second_name: str | None  
    email: EmailStr  
  
    id: int  
    is_reader: bool  
    is_author: bool  
    is_admin: bool  
    created_at: datetime  
    updated_at: datetime  
  
  
class LoginUser(BaseModel):  
    username: str  
    password: str  
  
  
class Token(BaseModel):  
    access_token: str  
    token_type: str = "Bearer"  
  
  
class RefreshToken(BaseModel):  
    refresh_token: str  
  
  
class TokenData(BaseModel):  
    sub: int  
    username: str  
    is_reader: bool  
    is_author: bool  
    is_admin: bool
```
Для примера возьму такие схемы, их отличие в том что тут есть схемы для токенов, для логина и регистрации, но в остальном синтаксически все также, отличия только логические

Также чтобы шифровать пароль и выдавать пользователю JWT и REFRESH токены надо ознакомиться с этими материалами [[Работа с JWT токеном]] [[Хэширование паролей]] [[Генерация приватного и публичного ключей]] [[Настройка settings для использования токенов сохраненных в файлах]]

Далее необходимо сделать круд операции для создания пользователя и получения его из базы данных [[Read запрос в базу данных]] [[Create запрос в базу данных]]
```
async def create_user(  
        user_data: CreateUser,  
        session: AsyncSession  
) -> UserResponse:  
    stmt = select(User).where(User.username == user_data.username)  
    find_user = await session.execute(stmt)  
    if find_user.scalar_one_or_none():  
        raise HTTPException(  
            status_code=status.HTTP_409_CONFLICT,  
            detail="User with this username already registered"  
        )  
  
    user_data.password = get_password_hash(user_data.password)  
    user = User(**user_data.dict())  
    session.add(user)  
    await session.commit()  
    await session.refresh(user)  
    return UserResponse.model_validate(user)  
  
  
async def get_user_for_login(  
    user_data: LoginUser,  
    session: AsyncSession,  
):  
    stmt = select(User).where(User.username == user_data.username)  
    result = await session.execute(stmt)  
    user = result.scalar_one_or_none()  
  
    if not user:  
        raise HTTPException(  
            status_code=status.HTTP_401_UNAUTHORIZED,  
            detail="Incorrect username or password"  
        )  
  
    if verify_password(user_data.password, user.password):  
        return user  
    else:  
        raise HTTPException(  
            status_code=status.HTTP_401_UNAUTHORIZED,  
            detail="Incorrect username or password"  
        )
```

На основе [[Работа с JWT токеном]] этого материала необходимо сделать две функции для того чтобы создавать токен аутентификации и расшифровывать его

```
def create_access_token(data: dict, expires_delta=None):  
    data_dict = data.copy()  
    expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)  
    data_dict["exp"] = expire  
    data_dict["type"] = "access"  
    return jwt.encode(data_dict, settings.JWT_PRIVATE_KEY.read_text(), algorithm=settings.ALGORITHM)
```

```
def decode_token(token: str):  
    from core.settings import settings  
    try:  
        return jwt.decode(token, settings.JWT_PUBLIC_KEY.read_text(), algorithms=[settings.ALGORITHM])  
    except jwt.ExpiredSignatureError:  
        raise HTTPException(status_code=401, detail="Token expired")  
    except jwt.InvalidTokenError:  
        raise HTTPException(status_code=401, detail="Invalid token")  
    except Exception as e:  
        raise HTTPException(status_code=401, detail="Token decoding error")
```

Тут есть нюанс с полем expire [[Длительность жизни токена и длительность его хранения в cookie браузера]]

Дописать дополнительный функционал для того чтобы получать интересующие поля напрямую в роутах через [[Depends]]

```
async def get_current_user_from_cookie(  
        request: Request,  
) -> TokenData:  
    credentials_exception = HTTPException(  
        status_code=status.HTTP_401_UNAUTHORIZED,  
        detail="Could not validate credentials",  
    )  
    token = request.cookies.get("access_token")  
    if not token:  
        raise credentials_exception  
  
    try:  
        payload = decode_token(token)  
  
        return TokenData(  
            sub=int(payload["sub"]),  
            username=payload["username"],  
            is_reader=payload.get("is_reader", False),  
            is_author=payload.get("is_author", False),  
            is_admin=payload.get("is_admin", False),  
        )  
  
    except Exception:  
        raise credentials_exception  
  
  
async def get_current_reader(current_user: TokenData = Depends(get_current_user_from_cookie)):  
    if not current_user.is_reader:  
        raise HTTPException(  
            status_code=status.HTTP_403_FORBIDDEN,  
            detail="You do not have permission to perform this operation"  
        )  
    return current_user  
  
  
async def get_current_author(current_user: TokenData = Depends(get_current_user_from_cookie)):  
    if not current_user.is_author:  
        raise HTTPException(  
            status_code=status.HTTP_403_FORBIDDEN,  
            detail="You do not have permission to perform this operation"  
        )  
    return current_user  
  
  
async def get_current_admin(current_user: TokenData = Depends(get_current_user_from_cookie)):  
    if not current_user.is_admin:  
        raise HTTPException(  
            status_code=status.HTTP_403_FORBIDDEN,  
            detail="You do not have permission to perform this operation"  
        )  
    return current_user
```

И дальше надо написать API для того чтобы пользователь мог взаимодействовать [[Написание endpointов]]

```
router = APIRouter(prefix="/auth", tags=["authentication"])  
  
  
@router.post("/registration")  
async def register(  
        user: CreateUser,  
        session: AsyncSession = Depends(get_db)  
):  
    await create_user(user, session)  
    return {"message": "User created successfully"}
    
@router.post("/login")  
async def get_current_user(  
        response: Response,  
        user_data: LoginUser,  
        session: AsyncSession = Depends(get_db)  
):  
    user = await get_user_for_login(user_data, session)  
  
    access_token = create_access_token(data={  
        "sub": str(user.id),  
        "username": user.username,  
        "is_reader": user.is_reader,  
        "is_author": user.is_author,  
        "is_admin": user.is_admin,  
    })
    
	response.set_cookie(  
	    key="access_token",  
	    value=access_token,  
	    httponly=True,  
	    secure=True,  
	    samesite="lax",  
	    max_age=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60,  
	    path="/"  
)
	
	return Token(access_token=access_token)
	
@router.post("/logout")  
async def logout(response: Response):  
    response.delete_cookie(key="access_token", path="/")  
    return {"message": "Logged out successfully"}  
  
  
@router.get("/me", response_model=UserResponse)  
async def get_me(current_user: UserResponse = Depends(get_current_user_from_cookie)):  
    return current_user
```
