Интеграционные тесты нужны для того чтобы тестировать полный цикл работы приложения в изолированной среде, то-есть создается отдельная тестовая изолированная база данных аналогичная той которая используется в продакшене, поднимаются тестовые сервера и все прочее, полностью эммулируется работа реальной программы. Данные тесты очень затратны по ресурсам в отличии от unit-тестов, так как для каждого теста создается изолированное окружение и закрывается.

```
from datetime import date 
  
import pytest  
from httpx import AsyncClient  
  
  
@pytest.mark.asyncio  
async def test_create_record_today(ac: AsyncClient):  
    payload = {  
        "phone_number": "+78005553535",  
        "date": str(date.today()),  
        "time": "14:30:00",  
        "notes": "Test note"  
    }  
    response = await ac.post("/v1/record/create_record", json=payload)  
  
    assert response.status_code == 200  
    response = response.json()  
  
    assert response["id"] == 1  
    assert response["date"] == payload["date"]  
    assert response["time"] == payload["time"]  
    assert response["status"] == "created"  
    assert response["price"] == 0  
    assert response["notes"] == payload["notes"]  
    assert response["user_id"] == 1
```

Разберем на примере данного теста. Данный тест тестирует API приложения. Про то как делать подмену базы данных в fastapi расписано в [[Создание тестовой базы данных]], а также стоит уделить внимание тому как эмулировать работу сервера [[Эмуляция работы сервера для тестов при помощи ASGITransport]]. В данном тесте я передаю json по url при помощи AsyncClient используя post запрос. Дальше начинаем проверять при помощи assert условия. Тут рекомендуется проверять все, для верности и максимально подробно, так как в случае изменений ошибки могут вылазить в самых неожиданных местах.