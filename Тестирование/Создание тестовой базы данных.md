Чтобы создать тестовую базу данных необходимо будет создавать фикстуру [[Фикситуры]] и указывать область видимости на саму функцию `@pytest.fixture(scope="function")`.
Дальше как и в случае с работой с обычной базой данных надо сделать движок для генерации подключений и функцию которая будет давать сессию для работы с подключениями:
```
@pytest.fixture(scope="function")  
async def test_engine():  
    engine = create_async_engine(  
        settings.TEST_DATABASE_URL,  
        future=True  
    )  
    yield engine  
    await engine.dispose()  
  
  
@pytest.fixture(scope="function")  
async def session(test_engine) -> AsyncGenerator[AsyncSession, None]:  
    session_factory = async_sessionmaker(  
        test_engine,  
        expire_on_commit=False  
    )  
    async with session_factory() as session:  
        yield session
```
Но так как мы работаем с alembic [[alembic, Миграции баз данных]], все эти миграции необходимо применять и к тестовой базе данных, для того чтобы алембик позволил нам динамически изменять при подключении снаружи url базы данных к которой он применит миграции нужно в migrations/env.py поменять функцию 
```
def run_migrations_online() -> None:  
    connectable = config.attributes.get("connection", None)  
  
    if connectable is not None:  
        do_run_migrations(connectable)  
    else:  
        engine = engine_from_config(  
            config.get_section(config.config_ini_section, {}),  
            prefix="sqlalchemy.",  
            poolclass=pool.NullPool,  
        )  
        with engine.connect() as connection:  
            do_run_migrations(connection)
```
Она буквально проверяет, есть ли внешнее подключение, если нет то запускает в обычном режиме, если есть, то запускает альтернативный вариант с подменой ссылки.
Теперь напишем фикстуру, которая будет применять миграции к тестовой базе данных
```
@pytest.fixture(scope="function", autouse=True)  
async def setup_db(test_engine):  
    alembic_cfg = Config("alembic.ini")  
  
    alembic_cfg.set_main_option(  
        "sqlalchemy.url",  
        settings.TEST_DATABASE_URL  
    )  
  
    async with test_engine.begin() as conn:  
        await conn.run_sync(lambda sync_conn: _run_upgrade(alembic_cfg, sync_conn))  
  
    yield  
  
    async with test_engine.begin() as conn:  
        await conn.run_sync(lambda sync_conn: _run_downgrade(alembic_cfg, sync_conn))  
  
  
def _run_upgrade(config, connection):  
    config.attributes["connection"] = connection  
    command.upgrade(config, "head")  
  
  
def _run_downgrade(config, connection):  
    config.attributes["connection"] = connection  
    command.downgrade(config, "base")
```
Также помимо функции которая применить миграции сделал две вспомогательные функции которые будут поднимать миграции и откатывать их.

Получается у нас создается одна база данных, много движков и сессий и для каждого теста свой движок, сессия, поднятие и откат миграций, за счет этого нету временной затраты на перезагрузку контейнера, только на применение и откат миграции.